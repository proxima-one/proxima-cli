// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).$loaderName.LoadAll(obj.$input)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}
####
// func (r *queryResolver) $EntityNames(ctx context.Context, where *string, orderBy *string, direction *bool, first *int, last *int, limit *int, prove *bool) ([]*models.$EntityName, error) {
	args := DefaultInputs
	if prove != nil {
		args["prove"] = *prove
	}
	if limit != nil {
		args["limit"] = *limit
	}
	if first != nil {
		args["first"] = *first
	}
	if last != nil {
		args["last"] = *last
	}
	if direction != nil {
		args["direction"] = *direction
	}
	if order_by != nil {
		args["order_by"] = *order_by
	}
	if where != nil {
		args["where"] = *where
	}
	table, _ := r.db.GetTable("$EntityNames")
	result, err := table.Search(args["where"].(string), args["order_by"].(string), args["direction"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool), args)
	if err != nil {
		return nil, err
	}
	value := make([]*models.$EntityName, 0)
	for _, dataRow := range result {
		var val models.$EntityName
		json.Unmarshal(dataRow.GetValue(), &val)
		val.Proof = GenerateProof(data.GetProof())
		value = append(value, &val)
	}
	return value, nil
//}
