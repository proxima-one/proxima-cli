"use strict";
//imports
//path to config templates
const yaml = require("js-yaml");
const fs = require("fs-extra");

const schemaGenConfigTemplateFilePath = require.resolve(
  "./schemaGenConfigTemplate.yml"
);
const dataloaderGen = require("../data-vertex-node/index.js");

//schemaEntityTemplate //template
const schemaTypescriptTemplate = fs.readFileSync(
  require.resolve("./schemaTypescriptTemplates.ts")
);

const ethereumTypescriptTemplate = fs.readFileSync(
  require.resolve("./ethereumTypescriptTemplates.ts")
);

function updateEthereumTypescriptTypes(schemaFile, typescriptOutputPath) {
  let templateFile = ethereumTypescriptTemplate;
  let files = fs.readdirSync(typescriptOutputPath); //get files from typescriptOutputPath?

  for (const f of files) {
    let file = typescriptOutputPath + "/" + f.toString();

    if (fs.pathExistsSync(file) && file.toString().includes(".d.ts")) {
      let fileText = fs.readFileSync(file).toString();
      fileText = processEthereumTypescriptTemplate(
        file,
        templateFile,
        fileText
      );
      fs.outputFileSync(file, fileText);
    }
  }
}

function processEthereumTypescriptTemplate(file, templateString, fileText) {
  let oldStr = "attach(addressOrName: string): this;";
  let newStr = oldStr + "\n" + templateString;
  return fileText.replace(oldStr, newStr);
}

function updateSchemaTypescriptTypes(schemaFile, typescriptOutputPath) {
  if (!typescriptOutputPath.includes(".ts")) {
    typescriptOutputPath += "/models.ts";
  }
  //export type Scalars = {
  let fileText = fs.readFileSync(typescriptOutputPath).toString();

  let templateFile = schemaTypescriptTemplate;
  fileText = processSchemaTypescriptTemplate(
    schemaFile,
    templateFile,
    fileText
  );
  fs.outputFileSync(typescriptOutputPath, fileText);
}

function processSchemaTypescriptTemplate(schemaFile, entityTemplate, fileText) {
  let entities = dataloaderGen.getDataloaders({}, schemaFile);
  let processedText = fileText;
  let templateList = entityTemplate.toString().split("####");
  let entityTemplateImports = entityTemplate[0];
  let entityFnTemplate = templateList[1];
  let entityGeneralTemplate = templateList[2];
  for (const [name, entity] of Object.entries(entities)) {
    let eOldStr = "typename?: '$EntityName';\n"
      .split("$EntityName")
      .join(entity.entityName);

    let entityNewStr = eOldStr + entityFnTemplate;
    processedText = processedText
      .replace(eOldStr, entityNewStr)
      .split("$EntityName")
      .join(entity.entityName);
  }

  processText += entityGeneralTemplate;

  return templateEntityImports + processedText;
}

function updateTypescriptGenConfiguration(
  schemaFile,
  typescriptOutputPath,
  outputConfigGenFile = "./codegen.yml"
) {
  let outFile = typescriptOutputPath + "/models.ts";
  //yaml.safeLoad(fs.readFileSync(schemaGenConfigTemplateFilePath));
  let scalars = { BigDecimal: "number", BigInt: "number" };
  let declarationKind = {
    type: "class",
    input: "type",
  };
  let typeScriptPlugins = [
    "typescript",
    "typescript-operations",
    "typescript-graphql-request",
  ];
  let typeScriptConfig = {
    namingConvention: "keep",
    //useImplementingTypes: true,
    //noExport: false,
    //rawRequest: true,
    declarationKind: declarationKind,
    scalars: scalars,
  };

  let generateConfig = {};
  generateConfig[outFile] = {
    plugins: typeScriptPlugins,
    config: typeScriptConfig,
  };
  let config = {
    schema: schemaFile,
    generates: generateConfig,
  };

  fs.outputFileSync(outputConfigGenFile, yaml.safeDump(config));
}

const schemaTypescriptGenerator = {
  updateSchemaTypescriptTypes,
  updateTypescriptGenConfiguration,
};
const ethTypescriptGenerator = { updateEthereumTypescriptTypes };

module.exports = {
  schemaTypescriptGenerator,
  ethTypescriptGenerator,
};
