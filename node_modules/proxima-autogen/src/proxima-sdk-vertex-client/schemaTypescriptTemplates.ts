import {vertexClient, Fetch} from "./VertexClient/index.ts"
import {ether} from 'ether.js';
import { useApolloClient } from '@apollo/client';
//global var?
####
    constructor(?id: string): this {  this.id = id }
    static load(id: string, ?prove: bool): this {
      var operation = Query
      var loadFn = $EntityName
      var loadArgs = Query$EntityNameArgs{id, prove}
      return Fetch(operation, loadFn, loadArgs)
    }
    save(): void {
      var operation = Mutation;
      var saveFn = put$EntityName;
      var saveArgs = Mutationput$EntityNameArgs{input: this.toInputArgs()};
      return Fetch(operation, saveFn, saveArgs)
    }
    toInputArgs(): $EntityNameInput{ //input
      let input = $EntityNameInput{} //input
      let fields = Object.keys(this)
      for (let fieldName of fields) {
        let hasField = this.getOwnProperty(fieldName)
        let fieldIdName = lowercaseFirstLetter(fieldName.replace("Id", ""))
        let hasFieldId = this.getOwnProperty(fieldIdName)

        if (!hasFieldId && !hasField) {continue}
        let fieldVal = getProperty(this, fieldName)

        if (hasFieldId) {
          fieldVal = getProperty(this, fieldIdName)
          let isList = Array.isArray(fieldVal);
          if (!isList) {
            fieldVal = getProperty(fieldVal, "id")
          } else {
            fieldVal = fieldVal.map(v => v.id)
          }
        }
        setProperty(input, fieldVal)
      }
      return input
}
####
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key]; // Inferred type is T[K]
}
function setProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]) {
  obj[key] = value;
}
function lowercaseFirstLetter(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
