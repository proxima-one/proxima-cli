package resolvers

import ( 
dataloader "github.com/proxima-one/proxima-data-vertex/pkg/dataloaders"
models "github.com/proxima-one/proxima-data-vertex/pkg/models"
json "github.com/json-iterator/go"
proximaIterables "github.com/proxima-one/proxima-db-client-go/pkg/iterables"
gql "github.com/proxima-one/proxima-data-vertex/pkg/gql"
"context"
)

func (r *dPoolResolver) Users(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).UserById.LoadAll(obj.UserIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *dPoolResolver) Deposits(ctx context.Context, obj *models.DPool) ([]*models.Deposit, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).DepositById.LoadAll(obj.DepositIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *dPoolResolver) Funders(ctx context.Context, obj *models.DPool) ([]*models.Funder, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).FunderById.LoadAll(obj.FunderIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *dPoolResolver) Fundings(ctx context.Context, obj *models.DPool) ([]*models.Funding, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).FundingById.LoadAll(obj.FundingIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *dPoolListResolver) Pools(ctx context.Context, obj *models.DPoolList) ([]*models.DPool, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).DPoolById.LoadAll(obj.DPoolIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *depositResolver) User(ctx context.Context, obj *models.Deposit) (*models.User, error) {
	return dataloader.For(ctx).UserById.LoadThunk(obj.UserID)()
}


func (r *depositResolver) Pool(ctx context.Context, obj *models.Deposit) (*models.DPool, error) {
	return dataloader.For(ctx).DPoolById.LoadThunk(obj.DPoolID)()
}


func (r *funderResolver) Pools(ctx context.Context, obj *models.Funder) ([]*models.DPool, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).DPoolById.LoadAll(obj.DPoolIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *funderResolver) Fundings(ctx context.Context, obj *models.Funder) ([]*models.Funding, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).FundingById.LoadAll(obj.FundingIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *funderResolver) TotalInterestByPool(ctx context.Context, obj *models.Funder) ([]*models.FunderTotalInterest, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).FunderTotalInterestById.LoadAll(obj.FunderTotalInterestIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *funderTotalInterestResolver) Funder(ctx context.Context, obj *models.FunderTotalInterest) (*models.Funder, error) {
	return dataloader.For(ctx).FunderById.LoadThunk(obj.FunderID)()
}


func (r *funderTotalInterestResolver) Pool(ctx context.Context, obj *models.FunderTotalInterest) (*models.DPool, error) {
	return dataloader.For(ctx).DPoolById.LoadThunk(obj.DPoolID)()
}


func (r *fundingResolver) Funder(ctx context.Context, obj *models.Funding) (*models.Funder, error) {
	return dataloader.For(ctx).FunderById.LoadThunk(obj.FunderID)()
}


func (r *fundingResolver) Pool(ctx context.Context, obj *models.Funding) (*models.DPool, error) {
	return dataloader.For(ctx).DPoolById.LoadThunk(obj.DPoolID)()
}


func (r *mutationResolver) UpdateDPoolList(ctx context.Context, input models.DPoolListInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("DPoolLists")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *mutationResolver) UpdateDPool(ctx context.Context, input models.DPoolInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("DPools")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *mutationResolver) UpdateUser(ctx context.Context, input models.UserInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("Users")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *mutationResolver) UpdateUserTotalDeposit(ctx context.Context, input models.UserTotalDepositInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("UserTotalDeposits")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *mutationResolver) UpdateDeposit(ctx context.Context, input models.DepositInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("Deposits")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *mutationResolver) UpdateFunder(ctx context.Context, input models.FunderInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("Funders")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *mutationResolver) UpdateFunderTotalInterest(ctx context.Context, input models.FunderTotalInterestInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("FunderTotalInterests")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *mutationResolver) UpdateFunding(ctx context.Context, input models.FundingInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("Fundings")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *mutationResolver) UpdateMPHHolder(ctx context.Context, input models.MPHHolderInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("MPHHolders")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *mutationResolver) UpdateMph(ctx context.Context, input models.MPHInput) (*bool, error) {
	args := DefaultInputs;
table, _ := r.db.GetTable("MPHs")
_, err := table.Put(*input.ID, input, args["prove"].(bool), args)
boolResult := true
if err != nil {
 boolResult = false
}
  return &boolResult, err

}


func (r *queryResolver) DPoolList(ctx context.Context, id string, prove *bool) (*models.DPoolList, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("DPoolLists")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.DPoolList;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) DPoolLists(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.DPoolList, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("DPoolLists")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.DPoolList, 0)
for _, dataRow := range result {
var val models.DPoolList;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) DPoolListSearch(ctx context.Context, queryText string, prove *bool) ([]*models.DPoolList, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("DPoolLists")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.DPoolList, 0)
for _, dataRow := range result {
var val models.DPoolList;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) DPool(ctx context.Context, id string, prove *bool) (*models.DPool, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("DPools")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.DPool;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) DPools(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.DPool, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("DPools")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.DPool, 0)
for _, dataRow := range result {
var val models.DPool;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) DPoolSearch(ctx context.Context, queryText string, prove *bool) ([]*models.DPool, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("DPools")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.DPool, 0)
for _, dataRow := range result {
var val models.DPool;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) User(ctx context.Context, id string, prove *bool) (*models.User, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("Users")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.User;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) Users(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.User, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("Users")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.User, 0)
for _, dataRow := range result {
var val models.User;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) UserSearch(ctx context.Context, queryText string, prove *bool) ([]*models.User, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("Users")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.User, 0)
for _, dataRow := range result {
var val models.User;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) UserTotalDeposit(ctx context.Context, id string, prove *bool) (*models.UserTotalDeposit, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("UserTotalDeposits")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.UserTotalDeposit;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) UserTotalDeposits(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.UserTotalDeposit, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("UserTotalDeposits")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.UserTotalDeposit, 0)
for _, dataRow := range result {
var val models.UserTotalDeposit;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) UserTotalDepositSearch(ctx context.Context, queryText string, prove *bool) ([]*models.UserTotalDeposit, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("UserTotalDeposits")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.UserTotalDeposit, 0)
for _, dataRow := range result {
var val models.UserTotalDeposit;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) Deposit(ctx context.Context, id string, prove *bool) (*models.Deposit, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("Deposits")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.Deposit;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) Deposits(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.Deposit, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("Deposits")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.Deposit, 0)
for _, dataRow := range result {
var val models.Deposit;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) DepositSearch(ctx context.Context, queryText string, prove *bool) ([]*models.Deposit, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("Deposits")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.Deposit, 0)
for _, dataRow := range result {
var val models.Deposit;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) Funder(ctx context.Context, id string, prove *bool) (*models.Funder, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("Funders")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.Funder;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) Funders(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.Funder, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("Funders")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.Funder, 0)
for _, dataRow := range result {
var val models.Funder;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) FunderSearch(ctx context.Context, queryText string, prove *bool) ([]*models.Funder, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("Funders")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.Funder, 0)
for _, dataRow := range result {
var val models.Funder;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) FunderTotalInterest(ctx context.Context, id string, prove *bool) (*models.FunderTotalInterest, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("FunderTotalInterests")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.FunderTotalInterest;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) FunderTotalInterests(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.FunderTotalInterest, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("FunderTotalInterests")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.FunderTotalInterest, 0)
for _, dataRow := range result {
var val models.FunderTotalInterest;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) FunderTotalInterestSearch(ctx context.Context, queryText string, prove *bool) ([]*models.FunderTotalInterest, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("FunderTotalInterests")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.FunderTotalInterest, 0)
for _, dataRow := range result {
var val models.FunderTotalInterest;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) Funding(ctx context.Context, id string, prove *bool) (*models.Funding, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("Fundings")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.Funding;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) Fundings(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.Funding, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("Fundings")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.Funding, 0)
for _, dataRow := range result {
var val models.Funding;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) FundingSearch(ctx context.Context, queryText string, prove *bool) ([]*models.Funding, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("Fundings")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.Funding, 0)
for _, dataRow := range result {
var val models.Funding;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) MPHHolder(ctx context.Context, id string, prove *bool) (*models.MPHHolder, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("MPHHolders")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.MPHHolder;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) MPHHolders(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.MPHHolder, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("MPHHolders")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.MPHHolder, 0)
for _, dataRow := range result {
var val models.MPHHolder;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) MPHHolderSearch(ctx context.Context, queryText string, prove *bool) ([]*models.MPHHolder, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("MPHHolders")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.MPHHolder, 0)
for _, dataRow := range result {
var val models.MPHHolder;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) Mph(ctx context.Context, id string, prove *bool) (*models.Mph, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
args["id"] = id
table, _ := r.db.GetTable("Mphs")
result, err := table.Get(id, args["prove"].(bool))
if err != nil {
  return nil, err
}
data := result.GetValue();
var val models.Mph;
json.Unmarshal(data.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())

return &value, nil

}


func (r *queryResolver) MPHs(ctx context.Context, from []*string, where *string, orderBy *string, asc *int, first *int, last *int, limit *int, prove *bool) ([]*models.Mph, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
if limit != nil {args["limit"] = *limit}
if first != nil {args["first"] = *first}
if last != nil {args["last"] = *last}
table, _ := r.db.GetTable("Mphs")
result, err := table.Search(args["from"].([]string), args["where"].(string), args["order_by"].(string), args["asc"].(bool), args["first"].(int), args["last"].(int), args["limit"].(int), args["prove"].(bool),  args)
if err != nil {
  return nil, err
}
value := make([]*models.Mph, 0)
for _, dataRow := range result {
var val models.Mph;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *queryResolver) MPHSearch(ctx context.Context, queryText string, prove *bool) ([]*models.Mph, error) {
	args := DefaultInputs;
if prove != nil { args["prove"] = *prove }
table, _ := r.db.GetTable("Mphs")
result, err := table.Query(queryText, args["prove"].(bool))
if err != nil {
  return nil, err
}
value := make([]*models.Mph, 0)
for _, dataRow := range result {
var val models.Mph;
json.Unmarshal(dataRow.GetValue(), &val)
val.Proof, _ = GenerateProof(data.GetProof())
value = append(value, &val)
};
return value, nil

}


func (r *userResolver) Pools(ctx context.Context, obj *models.User) ([]*models.DPool, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).DPoolById.LoadAll(obj.DPoolIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *userResolver) Deposits(ctx context.Context, obj *models.User) ([]*models.Deposit, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).DepositById.LoadAll(obj.DepositIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *userResolver) TotalDepositByPool(ctx context.Context, obj *models.User) ([]*models.UserTotalDeposit, error) {
	// func (r *dPoolResolver) $EntityNames(ctx context.Context, obj *models.DPool) ([]*models.User, error) {
	//determine which set of ids to get
	entities, _ := dataloader.For(ctx).UserTotalDepositById.LoadAll(obj.UserTotalDepositIDs)
	var args map[string]interface{} = gql.GetFieldContext(ctx).Args
	//check argument context
	//context check the args, where, orderBy, orderDirection, first, last, prove
	//getDefaults/getTheContextArgs
	//from identifier,
	//use to get from context
	return proximaIterables.Search(entities, args["where"], args["orderBy"], args["direction"], args["first"], args["last"])
//}

}


func (r *userTotalDepositResolver) User(ctx context.Context, obj *models.UserTotalDeposit) (*models.User, error) {
	return dataloader.For(ctx).UserById.LoadThunk(obj.UserID)()
}


func (r *userTotalDepositResolver) Pool(ctx context.Context, obj *models.UserTotalDeposit) (*models.DPool, error) {
	return dataloader.For(ctx).DPoolById.LoadThunk(obj.DPoolID)()
}

// DPool returns gql.DPoolResolver implementation.

